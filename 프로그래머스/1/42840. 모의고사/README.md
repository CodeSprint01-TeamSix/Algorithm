# [level 1] 모의고사 - 42840 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42840) 

### 성능 요약

메모리: 36.9 MB, 시간: 3.34 ms

### 구분

코딩테스트 연습 > 완전탐색

### 채점결과

정확성: 100.0<br/>합계: 100.0 / 100.0

### 제출 일자

2024년 04월 01일 18:28:29

### 문제 설명

<p>수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.</p>

<p>1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...<br>
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...<br>
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...</p>

<p>1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.</p>

<h5>제한 조건</h5>

<ul>
<li>시험은 최대 10,000 문제로 구성되어있습니다.</li>
<li>문제의 정답은 1, 2, 3, 4, 5중 하나입니다.</li>
<li>가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.</li>
</ul>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>answers</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>[1,2,3,4,5]</td>
<td>[1]</td>
</tr>
<tr>
<td>[1,3,2,4,2]</td>
<td>[1,2,3]</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p>입출력 예 #1</p>

<ul>
<li>수포자 1은 모든 문제를 맞혔습니다.</li>
<li>수포자 2는 모든 문제를 틀렸습니다.</li>
<li>수포자 3은 모든 문제를 틀렸습니다.</li>
</ul>

<p>따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.</p>

<p>입출력 예 #2</p>

<ul>
<li>모든 사람이 2문제씩을 맞췄습니다.</li>
</ul>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges


## 처음 시도한 풀이와 문제점

```
function solution(answers) {
    let answer = [];
    let tmp = [0,0,0];
    let one = [1,2,3,4,5];
    let two = [2,1,2,3,2,4,2,5];
    let three = [3,3,1,1,2,2,4,4,5,5];
    
    for(let i = 0; i < answers.length; i++){
        if(answers[i] === one[i]){
            tmp[0]++;
        } if(answers[i] === two[i]){
            tmp[1]++;
        } if(answers[i] === three[i]){
            tmp[2]++;
        }
        continue;
    }
    
    let max = Math.max(...tmp);
    for(let i = 0; i < tmp.length; i++){
        if(max === tmp[i]){
            answer.push(i+1);
        }
    }
    
    return answer.length > 1 ? answer.sort((a,b) => a-b) : answer;
}
```

## 문제점

제공된 코드에서 여전히 문제가 있는 주된 이유는 각 수포자의 답안 패턴을 answers의 길이에 따라 반복시키지 않고 있기 때문입니다. 
즉, one[i], two[i], three[i]와 같이 인덱스 i를 사용하여 직접 접근하는 방식은 one, two, three 배열의 길이를 초과하는 경우에 올바른 답안과 비교할 수 없습니다. 
배열의 길이를 초과한 인덱스에 접근하려고 하면 undefined를 얻게 되므로, 예상치 못한 비교 결과를 초래합니다.

예를 들어, answers 배열의 길이가 6인 경우, 1번 수포자의 답안 패턴은 [1,2,3,4,5,1]이 되어야 합니다. 
하지만 주어진 코드는 one[5]의 값이 undefined이기 때문에, 6번째 문제에 대한 비교를 정확히 수행할 수 없습니다.

이 문제를 해결하기 위해서는 각 수포자가 찍는 방식을 answers 배열의 길이에 맞추어 동적으로 반복시킬 필요가 있습니다. 
이를 위해 각 수포자의 답안을 반복시키는 로직에 모듈로 연산(%)을 사용하여 현재 질문의 인덱스에 맞는 답안을 동적으로 가져오도록 수정해야 합니다.


